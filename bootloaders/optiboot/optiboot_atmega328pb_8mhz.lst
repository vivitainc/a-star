
optiboot_atmega328pb_8mhz.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000084  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000030  00007d00  00007d00  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .version      00000002  00007ffe  00007ffe  00000084  2**0
                  CONTENTS, READONLY
  3 .comment      00000011  00000000  00000000  00000086  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000028  00000000  00000000  00000097  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000001f7  00000000  00000000  000000bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000019b  00000000  00000000  000002b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000167  00000000  00000000  00000451  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000074  00000000  00000000  000005b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000013d  00000000  00000000  0000062c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000028  00000000  00000000  00000769  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  00000791  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007d00 <main>:
  //  SP points to RAMEND
  //  r1 contains zero
  //
  // If not, uncomment the following instructions:
  // cli();
  asm volatile ("clr __zero_reg__");
    7d00:	11 24       	eor	r1, r1
#ifdef __AVR_ATmega8__
  SP=RAMEND;  // This is done by hardware reset
#endif

  // Adaboot no-wait mod
  ch = MCUSR;
    7d02:	84 b7       	in	r24, 0x34	; 52
  MCUSR = 0;
    7d04:	14 be       	out	0x34, r1	; 52
  //  LED_PORT |= _BV(LED);
  //}

#if LED_START_FLASHES > 0
  // Set up Timer 1 for timeout counter
  TCCR1B = _BV(CS12) | _BV(CS10); // div 1024
    7d06:	85 e0       	ldi	r24, 0x05	; 5
    7d08:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
#endif
#ifndef SOFT_UART
  // Turn on the pull-up resistor for RX.
  PORTD |= (1 << 0);
    7d0c:	58 9a       	sbi	0x0b, 0	; 11
  UCSRA = _BV(U2X); //Double speed mode USART
  UCSRB = _BV(RXEN) | _BV(TXEN);  // enable Rx & Tx
  UCSRC = _BV(URSEL) | _BV(UCSZ1) | _BV(UCSZ0);  // config USART; 8N1
  UBRRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
#else
  UCSR0A = _BV(U2X0); //Double speed mode USART0
    7d0e:	82 e0       	ldi	r24, 0x02	; 2
    7d10:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
  UCSR0B = _BV(RXEN0) | _BV(TXEN0);
    7d14:	88 e1       	ldi	r24, 0x18	; 24
    7d16:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
  UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
    7d1a:	86 e0       	ldi	r24, 0x06	; 6
    7d1c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
  UBRR0L = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
    7d20:	80 e1       	ldi	r24, 0x10	; 16
    7d22:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
#endif
#endif
  while(1) { //test
  // PIN_EN_TX to high
  DDRB |= _BV(PINB0);
    7d26:	20 9a       	sbi	0x04, 0	; 4
  PORTB |= _BV(PINB0);
    7d28:	28 9a       	sbi	0x05, 0	; 5
  //PINB |= _BV(PINB0);
  //DDRB = DDRB  |  0x01;
  //PORTB = PORTB | 0x01; 

  // PIN_EN_RX to high
  DDRD |= _BV(PIND7);
    7d2a:	57 9a       	sbi	0x0a, 7	; 10
  PORTD |= _BV(PIND7);
    7d2c:	5f 9a       	sbi	0x0b, 7	; 11
    7d2e:	fb cf       	rjmp	.-10     	; 0x7d26 <main+0x26>
